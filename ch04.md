# 第4章 汇编语言程序范例

准备好所有开发工具之后，就可以开始学习汇编语言程序设计了。汇编语言桯序使用通用模板和格式（是使用的汇编器特定的），可以把它们用于所有应用程序的开发。

本章引导读者学习GNU汇编器的基本汇编语言程序模板。本章的第一节介绍汇编语言程序
中的通用项目，以及如何使用它们定义通用模板。下一节讲解－个范例程序，以及如何汇编和运行它。接下来将学习如何使用GNU调试器调试范例程序。本章的最后一节演示如何把C库函数井人汇编诘言程序中。

## 程序的组成

正如第1章“什么是汇编语言”中介绍的，汇编语言程序由定义好的段构成，每个段都有不
同的目的。三个最常用的段如下：
* 数据段
* bss段
* 文本段

所有礼编语言程序中都必须有文本段。这里是在可执行程序内声明指令码的地方。数据和
bss段是可选的，但是在程序中经常使用。数据段声明带有初始值的数据元素。这些数据元素用作汇编语言程序中的变量。bss段声明使用零（或者null) 值初始化的数据元素。这些数据元素最常用作汇编语言程序中的缓冲区。

下面几节介绍如何在为GNU汇编器编写的汇编语言程序中声明不同的段，GNU汇编器是本书中使用的汇编器。

### 定义段

GNU汇编器使用`.section`命令语旬声明段。`.section`语句只使用一个参数————它声明的段的类型。图4-1显示汇编语言程序的布局。

图4-1演示在程序中安排段的一般方式。bss段总是应该安/排在文本段之前，但是数据段可以移动到文本段之后，虽然这不是标准。除了完成功能性的要求之外，编写的汇编语言程序
还应该容易阅读。将所有数据定义集中在源代码的开头使其他程序员更加容易接手你的工作井且理解它。

![图4-1](pic/ch04/pic4-1.png "图4-1")

### 定义起始点

当汇编语言程序被转换为可执行文件肘，连接器必须知道指令码中的起始点是什么。对于只有单一指令路径的简单程序， 找到起始点通常不是问题。但是，对干使用分散在源代码各个位置的若干函数的更加复杂的程序，发现程序从哪里开始可能是个问题。

为了解决这个问题， GNU汇编器声明一个默认标签，或者说标识符，它应该用作应用程序的入口点。`_start`标签用于表明程序应该从这条指令开始运行。如果连接器找不到这个标签，它会生成错误消息：

```shell
$ ld bad-test.o -o bad-test
ld: warning: cannot find entry symbol _start; defaulting to 0000000000008054
```

就像链接器的输出显示的，如果链接器找不到`_start`标签，它就会试图查找程序的起始点，但是对于复杂的程序，不能保证链接器能正确地作出猜测。

也可以使用`_start`之外的其他标签作为起始点。可以使用链接器的`-e` 参数定义新的起始点的名称。

除了在应用程序中声明起始标签之外，还苦要为外部应用程序提供人口点。这是使用`.global`命令完成的。

`.global`命令声明外部程序可以访问的程序标签。如果编写被外部汇编语言或者C语言程序使用的一组工具，就应该使用`.global`命令声明每个函数段标签。

了解了这些信息，就可以为所有汇编语言程序创建基础模板。模板应该像下面这样：

```asm
.section .data

    <initialized data here>

.section .bss

    <uninitialized data here>

.section .text
.global _start
_start:

    <nstruction code goes here>
```

有了这样的模板，就准备好了开始编写汇编语言程序。下一节讲解一个范例应用程序，它展示如何从汇编语言程序源代码构建应用程序。

## 创建简单程序

现在是创建简单的汇编语言应用程序来演示这些组件如何结合在一起使用的时候了。最开
始，我们创建一个`hello world`的简单应用程序，即在终端打印一行字符串。

### 范例程序

这个程序是一个简单的应用程序，它仅仅向终端打印一行字符串。下面就是范例程序`hello_syscall.s`：

[hello_syscall.s](code/sample/hello_syscall.s ':include')

这个程序使用了许多不同的汇编语言指令。现在，不必过于担心这些语句是什么；以后的章节中将详细地讲解它们。目前请把注意力集中在如何在程序中安排指令、指令如何操作的流程以及源代码文件如何转换为可执行程序文件上。这样就不会给自己造成混乱，下面是对源代码如何工作的简要讲解。

首先，在数据段中声明了一个字符串：

```asm
.section .data
hello:
    .asciz	"hello, arm\n"
```

`.asciz`声明使用ASCII字符声明－个文本字符串，末尾会自动加上一个空字符。字符串元素被预定义并且放在内存中，其起始内存位置由标签`hello`指示。

读者应该认识程序模板中接下来的段落。它声明程序的指令码段和一般的起始标签：

```asm
.section .text
.global	_start
_start:
```

 程序首先将字符串`hello, arm\n`输出到控制台。

 ```asm
    mov r0, #1      // 文件描述符，1是标准输出
    ldr r1, =hello  // 字符串首地址
    mov r2, #12     // 字符串长度
    mov r7, #4      // write()的调用号是4，通过r7寄存器传递
    swi #0x0        // 触发系统调用
 ```

这个程序使用一个Linux系统调用(swi #0x0) 从Linux内核访问控制台显示。Linux内核提供了很多可以很容易地从汇编应用程序访问的预置函数。为了访问这些内核函数，必须使用`swi`指令码，它生成具有`0x0`值的软件中断。执行的具体函数由`r7`寄存器的值来确定。如果没有这个内核函数，就必须自己把每个输出字符发送到正确的显示器I/0地址。Linux系统调用为汇编语言程序员节省了大量时间。

Linux的`write`系统调用用于把字节写人文件。下面是`write`系统调用的参数：
* r7包含系统调用值。
* r0包含要写人的文件描述符。
* r1包含字符串的开头。
* r2包含字符串的长度。

如果读者熟悉UNIX, 就会知道几乎所有东西都被作为文件处理。标准输出（STDOUT）表示当前会话的显示终端，它的文件描述符为1。写人到这个文件描述符将在控制台屏幕上显示信息。

要显示的字节采用从之读取信息的内存位置以及要显示的字节数量的形式进行定义。r1寄存器加载的是hello标签的内存位置，它定义字符串的开头。因为输出字符串的长度总是相同的．所以可以在r2寄存器中硬编码长度值。

显示了字符串之后，就该干净地退出程序了。同样，Linux系统调用能够提供帮助。通过使用系统调用1（退出函数），程序被正确地终止，并且返回到命令提示符。r0寄存器包含程序返回给shell的退出代码值。可以使用r0寄存器的内容，按照汇编语言程序内的情况在shell脚本程序中生成不同的结果。零值表示程序成功地执行了。这里使用了一个区别于0的数字42。

```asm
    mov r0, #42     // 退出码
    mov r7, #1      // exit()的调用号是1
    swi #0x0        // 触发系统调用
```

### 构建可执行程序

有了保存为`hello_syscall.s`的汇编语言源代码程序，可以使用GNU汇编器和GNU连接器构建可执行程序，方法如下：

```shell
$ as -o hello_syscall.o hello_syscall.s
$ ld -o hello_syscall hello_syscall.o
```

这些命令的输出没有什么令人过于兴奋的（当然，除非代码中出现了一些打字错误）。第一个步骤使用as命令把汇编语言源代码汇编为目标代码文件`hello_syscall.o`。第二个步骤使用ld把目标代码文件链接为可执行文件hello_syscall。

### 运行可执行程序

连接器生成可执行程序文件之后，就可以运行它了。下面是在我的开发板上程序愉出的例子：

```shell
$ ./hello_syscall
hello, arm
$ echo $?
42
```

非常好！桯序按照预期运行！并且程序的返回码也是预期的42。

### 使用编译器进行汇编

因为GNU通用编译器（GNU Common Compiler, gcc）使用GNU汇编器编译C代码，所以也可以使用它在单一步骤内汇编和链接汇编语言程序。虽然这不是常用的方法，但是在必要的时候也是有用的。

使用gcc汇编程序时有一个问题. GNU连接器查找_start标签以便确定程序的开始位置．但是gcc查找的是main标签（读者也许已经通过C或者C++程序设计了解了它）。必须把程序中的_start标签和定义标签的global命令都改成下面这样：

```asm
.section .text
.global main
main:
```

改动之后，汇编和链接程序就没什么问题了：

```shell
$ gcc -o hello_syscall hello_syscall.s
$ ./hello_syscall
hello, arm
```

选择一个合适的demo程序演示。TODD。
* 调用系统调用，https://man7.org/linux/man-pages/man2/syscall.2.html
* 调用库函数

